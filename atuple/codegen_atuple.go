// Code generated by codegen.go DO NOT EDIT.
// Version: 0.0.0
// Checksum: 6160841775643786139

package atuple

// Packed2 is an array-backed tuple with 2 elements.
type Packed2[T1, T2 any] [2]any

// Pack2 returns an array-backed tuple of with 2 items.
func Pack2[T1, T2 any](
	e1 T1, e2 T2,
) Packed2[T1, T2] {
	return [2]any{
		e1, e2,
	}
}

// Item1 returns the element at index 1 (1-based), with the original
// type.
func (t Packed2[T1, T2]) Item1() T1 {
	out, _ := t[0].(T1)
	return out
}

// Item2 returns the element at index 2 (1-based), with the original
// type.
func (t Packed2[T1, T2]) Item2() T2 {
	out, _ := t[1].(T2)
	return out
}

// Unpack returns each element of the tuple as separate return values and with
// their original type, useful for assigning to multiple variables at once or
// passing into other functions.
func (t Packed2[T1, T2]) Unpack() (T1, T2) {
	return t[0].(T1), t[1].(T2)
}

// Packed3 is an array-backed tuple with 3 elements.
type Packed3[T1, T2, T3 any] [3]any

// Pack3 returns an array-backed tuple of with 3 items.
func Pack3[T1, T2, T3 any](
	e1 T1, e2 T2, e3 T3,
) Packed3[T1, T2, T3] {
	return [3]any{
		e1, e2, e3,
	}
}

// Item1 returns the element at index 1 (1-based), with the original
// type.
func (t Packed3[T1, T2, T3]) Item1() T1 {
	out, _ := t[0].(T1)
	return out
}

// Item2 returns the element at index 2 (1-based), with the original
// type.
func (t Packed3[T1, T2, T3]) Item2() T2 {
	out, _ := t[1].(T2)
	return out
}

// Item3 returns the element at index 3 (1-based), with the original
// type.
func (t Packed3[T1, T2, T3]) Item3() T3 {
	out, _ := t[2].(T3)
	return out
}

// Unpack returns each element of the tuple as separate return values and with
// their original type, useful for assigning to multiple variables at once or
// passing into other functions.
func (t Packed3[T1, T2, T3]) Unpack() (T1, T2, T3) {
	return t[0].(T1), t[1].(T2), t[2].(T3)
}

// Packed4 is an array-backed tuple with 4 elements.
type Packed4[T1, T2, T3, T4 any] [4]any

// Pack4 returns an array-backed tuple of with 4 items.
func Pack4[T1, T2, T3, T4 any](
	e1 T1, e2 T2, e3 T3, e4 T4,
) Packed4[T1, T2, T3, T4] {
	return [4]any{
		e1, e2, e3, e4,
	}
}

// Item1 returns the element at index 1 (1-based), with the original
// type.
func (t Packed4[T1, T2, T3, T4]) Item1() T1 {
	out, _ := t[0].(T1)
	return out
}

// Item2 returns the element at index 2 (1-based), with the original
// type.
func (t Packed4[T1, T2, T3, T4]) Item2() T2 {
	out, _ := t[1].(T2)
	return out
}

// Item3 returns the element at index 3 (1-based), with the original
// type.
func (t Packed4[T1, T2, T3, T4]) Item3() T3 {
	out, _ := t[2].(T3)
	return out
}

// Item4 returns the element at index 4 (1-based), with the original
// type.
func (t Packed4[T1, T2, T3, T4]) Item4() T4 {
	out, _ := t[3].(T4)
	return out
}

// Unpack returns each element of the tuple as separate return values and with
// their original type, useful for assigning to multiple variables at once or
// passing into other functions.
func (t Packed4[T1, T2, T3, T4]) Unpack() (T1, T2, T3, T4) {
	return t[0].(T1), t[1].(T2), t[2].(T3), t[3].(T4)
}

// Packed5 is an array-backed tuple with 5 elements.
type Packed5[T1, T2, T3, T4, T5 any] [5]any

// Pack5 returns an array-backed tuple of with 5 items.
func Pack5[T1, T2, T3, T4, T5 any](
	e1 T1, e2 T2, e3 T3, e4 T4, e5 T5,
) Packed5[T1, T2, T3, T4, T5] {
	return [5]any{
		e1, e2, e3, e4, e5,
	}
}

// Item1 returns the element at index 1 (1-based), with the original
// type.
func (t Packed5[T1, T2, T3, T4, T5]) Item1() T1 {
	out, _ := t[0].(T1)
	return out
}

// Item2 returns the element at index 2 (1-based), with the original
// type.
func (t Packed5[T1, T2, T3, T4, T5]) Item2() T2 {
	out, _ := t[1].(T2)
	return out
}

// Item3 returns the element at index 3 (1-based), with the original
// type.
func (t Packed5[T1, T2, T3, T4, T5]) Item3() T3 {
	out, _ := t[2].(T3)
	return out
}

// Item4 returns the element at index 4 (1-based), with the original
// type.
func (t Packed5[T1, T2, T3, T4, T5]) Item4() T4 {
	out, _ := t[3].(T4)
	return out
}

// Item5 returns the element at index 5 (1-based), with the original
// type.
func (t Packed5[T1, T2, T3, T4, T5]) Item5() T5 {
	out, _ := t[4].(T5)
	return out
}

// Unpack returns each element of the tuple as separate return values and with
// their original type, useful for assigning to multiple variables at once or
// passing into other functions.
func (t Packed5[T1, T2, T3, T4, T5]) Unpack() (T1, T2, T3, T4, T5) {
	return t[0].(T1), t[1].(T2), t[2].(T3), t[3].(T4), t[4].(T5)
}

// Packed6 is an array-backed tuple with 6 elements.
type Packed6[T1, T2, T3, T4, T5, T6 any] [6]any

// Pack6 returns an array-backed tuple of with 6 items.
func Pack6[T1, T2, T3, T4, T5, T6 any](
	e1 T1, e2 T2, e3 T3, e4 T4, e5 T5, e6 T6,
) Packed6[T1, T2, T3, T4, T5, T6] {
	return [6]any{
		e1, e2, e3, e4, e5, e6,
	}
}

// Item1 returns the element at index 1 (1-based), with the original
// type.
func (t Packed6[T1, T2, T3, T4, T5, T6]) Item1() T1 {
	out, _ := t[0].(T1)
	return out
}

// Item2 returns the element at index 2 (1-based), with the original
// type.
func (t Packed6[T1, T2, T3, T4, T5, T6]) Item2() T2 {
	out, _ := t[1].(T2)
	return out
}

// Item3 returns the element at index 3 (1-based), with the original
// type.
func (t Packed6[T1, T2, T3, T4, T5, T6]) Item3() T3 {
	out, _ := t[2].(T3)
	return out
}

// Item4 returns the element at index 4 (1-based), with the original
// type.
func (t Packed6[T1, T2, T3, T4, T5, T6]) Item4() T4 {
	out, _ := t[3].(T4)
	return out
}

// Item5 returns the element at index 5 (1-based), with the original
// type.
func (t Packed6[T1, T2, T3, T4, T5, T6]) Item5() T5 {
	out, _ := t[4].(T5)
	return out
}

// Item6 returns the element at index 6 (1-based), with the original
// type.
func (t Packed6[T1, T2, T3, T4, T5, T6]) Item6() T6 {
	out, _ := t[5].(T6)
	return out
}

// Unpack returns each element of the tuple as separate return values and with
// their original type, useful for assigning to multiple variables at once or
// passing into other functions.
func (t Packed6[T1, T2, T3, T4, T5, T6]) Unpack() (T1, T2, T3, T4, T5, T6) {
	return t[0].(T1), t[1].(T2), t[2].(T3), t[3].(T4), t[4].(T5), t[5].(T6)
}

// Packed7 is an array-backed tuple with 7 elements.
type Packed7[T1, T2, T3, T4, T5, T6, T7 any] [7]any

// Pack7 returns an array-backed tuple of with 7 items.
func Pack7[T1, T2, T3, T4, T5, T6, T7 any](
	e1 T1, e2 T2, e3 T3, e4 T4, e5 T5, e6 T6, e7 T7,
) Packed7[T1, T2, T3, T4, T5, T6, T7] {
	return [7]any{
		e1, e2, e3, e4, e5, e6, e7,
	}
}

// Item1 returns the element at index 1 (1-based), with the original
// type.
func (t Packed7[T1, T2, T3, T4, T5, T6, T7]) Item1() T1 {
	out, _ := t[0].(T1)
	return out
}

// Item2 returns the element at index 2 (1-based), with the original
// type.
func (t Packed7[T1, T2, T3, T4, T5, T6, T7]) Item2() T2 {
	out, _ := t[1].(T2)
	return out
}

// Item3 returns the element at index 3 (1-based), with the original
// type.
func (t Packed7[T1, T2, T3, T4, T5, T6, T7]) Item3() T3 {
	out, _ := t[2].(T3)
	return out
}

// Item4 returns the element at index 4 (1-based), with the original
// type.
func (t Packed7[T1, T2, T3, T4, T5, T6, T7]) Item4() T4 {
	out, _ := t[3].(T4)
	return out
}

// Item5 returns the element at index 5 (1-based), with the original
// type.
func (t Packed7[T1, T2, T3, T4, T5, T6, T7]) Item5() T5 {
	out, _ := t[4].(T5)
	return out
}

// Item6 returns the element at index 6 (1-based), with the original
// type.
func (t Packed7[T1, T2, T3, T4, T5, T6, T7]) Item6() T6 {
	out, _ := t[5].(T6)
	return out
}

// Item7 returns the element at index 7 (1-based), with the original
// type.
func (t Packed7[T1, T2, T3, T4, T5, T6, T7]) Item7() T7 {
	out, _ := t[6].(T7)
	return out
}

// Unpack returns each element of the tuple as separate return values and with
// their original type, useful for assigning to multiple variables at once or
// passing into other functions.
func (t Packed7[T1, T2, T3, T4, T5, T6, T7]) Unpack() (T1, T2, T3, T4, T5, T6, T7) {
	return t[0].(T1), t[1].(T2), t[2].(T3), t[3].(T4), t[4].(T5), t[5].(T6), t[6].(T7)
}
