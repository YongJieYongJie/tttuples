// codegen generates (from text/template template) multiple functions with
// increasing numbers of certain language element: type parameter, input
// argument, return value, element in return value.
//
// Example usage:
//     //go:generate codegen -N 10 --outfile generatedcode.go
//     var myFunctionTemplate = `
//     func myFunction()[{{ .T1_T2___TN }}] { ... }
//     `
//
// For details on the various template data provided (such as the .T1_T2___TN
// that will be replaced with "T1, T2, T3", assuming N = 3), refer to
// TemplateData struct.
package main

import (
	"bufio"
	"flag"
	"fmt"
	"hash/crc64"
	"os"
	"strconv"
	"strings"
	"text/template"
)

type args struct {
	N        int      // maximum number of elements (will generate functions from 2, 3, ..., to N)
	imports  []string // additional imports to add to the generated source file
	infile   string   // source file that containing the //go:generate line
	outfile  string   // destination file to write the generated code (relative to directory of infile)
	line     int      // line in the source file that containing the //go:generate line
	package_ string   // package of the source file containing the //go:generate line
}

func main() {
	args := parseArgs()
	tmpl, raw := parseTemplate(args)

	outfile, err := os.Create(args.outfile)
	if err != nil {
		panic(err)
	}

	outfile.WriteString(getHeader(getVersion(), getHash(raw), args.package_))

	if len(args.imports) != 0 {
		outfile.WriteString("\n")
		outfile.WriteString("import (\n")
		for _, imp := range args.imports {
			outfile.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
		}
		outfile.WriteString(")\n")
	}

	for i := 2; i <= args.N; i++ {
		outfile.WriteString("\n")
		err = tmpl.Execute(outfile, newTemplateData(i))
		if err != nil {
			panic(err)
		}
	}
}

func parseArgs() args {
	var N int
	var outfile string
	var imports string
	flag.IntVar(&N, "N", 23, "maximum number of element (will generate functions from 2, 3, ..., to N)")
	flag.StringVar(&outfile, "outfile", "", "destination file to write the generated code (relative to directory of original source file)")
	flag.StringVar(&imports, "imports", "", "comma-separated list of additional imports to add to the generated source file")
	flag.Parse()

	return args{
		N:        N,
		imports:  mustParseImports(imports),
		outfile:  outfile,
		infile:   os.Getenv("GOFILE"),
		line:     mustAtoi(os.Getenv("GOLINE")),
		package_: os.Getenv("GOPACKAGE"),
	}
}

func parseTemplate(args args) (parsed *template.Template, raw string) {
	sourceFile, err := os.Open(args.infile)
	if err != nil {
		panic(err)
	}

	scanner := bufio.NewScanner(sourceFile)

	var tmpl strings.Builder
	var currLine int
	for scanner.Scan() {
		currLine++
		if currLine <= args.line+1 {
			continue
		}
		line := scanner.Text()
		if line == "`" {
			break
		}
		tmpl.WriteString(line)
		tmpl.WriteRune('\n')
	}

	tmplRaw := tmpl.String()
	tmplParsed, err := template.New("").Parse(tmplRaw)
	if err != nil {
		panic(err)
	}
	return tmplParsed, tmplRaw
}

func mustAtoi(a string) int {
	i, err := strconv.Atoi(a)
	if err != nil {
		panic(err)
	}
	return i
}

func mustParseImports(imports string) []string {
	if strings.TrimSpace(imports) == "" {
		return nil
	}
	var out []string
	parsed := strings.Split(imports, ",")
	for _, imp := range parsed {
		trimmed := strings.TrimSpace(imp)
		if strings.Contains(trimmed, " ") {
			panic(fmt.Sprintf("error parsing import \"%s\", unexpected space character", imp))
		}
		out = append(out, trimmed)
	}
	return out
}

func getHeader(version string, checksum uint64, packageName string) string {
	header := `// Code generated by codegen.go DO NOT EDIT.
// Version: %v
// Checksum: %v

package %s
`
	return fmt.Sprintf(header, version, checksum, packageName)
}

func getVersion() string {
	return "0.0.0"
}

func getHash(tmplRaw string) uint64 {
	return crc64.Checksum([]byte(tmplRaw), crc64.MakeTable(crc64.ISO))
}
